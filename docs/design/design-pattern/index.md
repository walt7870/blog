# 设计模式

## 概述

设计模式是软件工程中针对特定问题的一套**可复用、通用、经过验证的设计解决方案**。它们并不是直接的代码实现，而是一种**可遵循的思想和结构模板**，帮助开发者在面对系统复杂性、模块解耦、扩展性设计等问题时，能够遵循最佳实践进行架构设计。设计模式强调**高内聚、低耦合、面向接口编程、开放封闭原则**等核心理念，使系统更具**可维护性、可读性、可扩展性与可复用性**。它们提升了团队协作效率和代码质量，也促进了设计思维的统一，降低了沟通成本。理解和合理运用设计模式，有助于构建更优雅、灵活、可演进的软件系统。

## 原则

🔹 1. 单一职责原则（SRP，Single Responsibility Principle）
> 定义： 一个类应该只有一个引起它变化的原因（即只承担一种职责）。

目的： 降低类的复杂性，提高可读性、可维护性。
举例： 把“打印订单”和“保存订单”分成两个类，而不是写在一个类中。

🔹 2. 开闭原则（OCP，Open/Closed Principle）
> 定义： 软件实体（类、模块、函数）应该对扩展开放，对修改关闭。

目的： 在不修改已有代码的前提下，通过扩展实现新功能。
实现方式： 依赖抽象，多用接口和抽象类，少改具体实现。

🔹 3. 里氏替换原则（LSP，Liskov Substitution Principle）
> 定义： 子类对象必须能够替换其父类对象，且行为保持一致。

目的： 保证继承的正确性和复用性，避免继承破坏程序逻辑。
例子： 如果 Bird 有 fly() 方法，Penguin 不能继承 Bird，因为企鹅不会飞。

🔹 4. 依赖倒置原则（DIP，Dependency Inversion Principle）
> 定义： 高层模块不应该依赖底层模块，二者都应依赖其抽象。

目的： 降低模块之间的耦合性。
实现方式： 多使用接口或抽象类，具体实现注入（如构造器注入、IOC）。

🔹 5. 接口隔离原则（ISP，Interface Segregation Principle）
> 定义： 使用多个专门的接口，而不是一个通用的“大而全”接口。

目的： 减少类对接口不需要部分的依赖。
例子： Printer 接口不应该强制实现 scan()，FaxMachine 应该有自己的接口。

🔹 6. 迪米特法则（LOD，Law of Demeter）
> 定义： 即最少感知原则，一个对象应该对其他对象有最少的了解。

目的： 降低对象之间的耦合，提高模块独立性。
实现方式： 尽量避免链式调用（如 a.getB().getC().doSomething()）。

🔹 7. 合成复用原则（CRP，Composite Reuse Principle）
> 定义： 优先使用“组合/聚合”而不是继承来达到复用目的。

目的： 降低类之间的耦合，提高系统的灵活性。

**总结记忆：**
> 单一职责要清晰，开闭原则易扩展；
> 里氏替换保行为，依赖倒置靠接口；
> 接口隔离重精简，最少知道降耦合；
> 合成复用不继承，灵活解耦更安全。



## 分类

### 创建型模式

**目的**：关注对象的创建方式，封装实例化逻辑，使系统与对象的创建解耦，提高灵活性。

| 模式名                          | 简要说明                                 |
| ---------------------------- | ------------------------------------ |
| **单例模式（Singleton）**          | 保证一个类只有一个实例，并提供全局访问点。常用于配置、线程池等共享资源。 |
| **工厂方法模式（Factory Method）**   | 定义一个创建对象的接口，由子类决定实例化哪个类，延迟到子类实现。     |
| **抽象工厂模式（Abstract Factory）** | 提供一系列相关或相互依赖对象的创建接口，而无需指定它们具体的类。     |
| **建造者模式（Builder）**           | 将一个复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。  |
| **原型模式（Prototype）**          | 通过复制现有实例来创建新对象，避免重复创建成本高的对象。         |

### 结构型模式

**目的：** 关注类与对象的组合方式，解决模块之间的耦合问题，提高代码复用性和灵活性。

| 模式名                  | 简要说明                            |
| -------------------- | ------------------------------- |
| **适配器模式（Adapter）**   | 将一个类的接口转换为客户端期望的另一个接口，实现接口兼容。   |
| **桥接模式（Bridge）**     | 将抽象部分与实现部分分离，使它们可以独立变化，解耦抽象与实现。 |
| **装饰器模式（Decorator）** | 动态地为对象添加功能，替代继承的方式扩展功能。         |
| **代理模式（Proxy）**      | 为其他对象提供一种代理以控制对这个对象的访问。         |
| **外观模式（Facade）**     | 提供一个统一接口，隐藏子系统的复杂性，对外提供简洁接口。    |
| **组合模式（Composite）**  | 将对象组合成树形结构，使客户端对单个对象与组合对象的使用一致。 |
| **享元模式（Flyweight）**  | 通过共享技术有效地支持大量细粒度对象，减少内存使用。      |

### 行为型模式

**目的：** 关注对象之间的职责分配与通信方式，解决对象协作过程中的耦合与扩展问题。

| 模式名                                | 简要说明                              |
| ---------------------------------- | --------------------------------- |
| **观察者模式（Observer）**                | 一对多依赖关系，当一个对象状态改变时，通知所有依赖它的对象。    |
| **策略模式（Strategy）**                 | 定义一系列算法，把它们封装起来并使它们可以相互替换。        |
| **模板方法模式（Template Method）**        | 定义算法骨架，子类可覆盖具体步骤而不改变结构。           |
| **责任链模式（Chain of Responsibility）** | 将请求沿着链传递，直到某个处理者处理它。              |
| **命令模式（Command）**                  | 将请求封装成对象，使参数化执行请求、排队请求成为可能。       |
| **状态模式（State）**                    | 允许对象在内部状态改变时改变行为，看起来像修改了其类。       |
| **访问者模式（Visitor）**                 | 封装对结构中各元素的操作，使其可以在不修改结构的前提下定义新操作。 |
| **中介者模式（Mediator）**                | 用中介对象封装一组对象的交互，避免对象间显式引用。         |
| **解释器模式（Interpreter）**             | 给定语言定义一个解释器，解释语言中的句子。             |
| **迭代器模式（Iterator）**                | 提供一种方法顺序访问集合对象的元素而不暴露内部结构。        |
| **备忘录模式（Memento）**                 | 保存对象状态以便恢复，常用于撤销操作。               |

### 总结对比

| 分类  | 关注点            | 特点                    |
| --- | -------------- | --------------------- |
| 创建型 | **如何创建对象**     | 解决复杂对象创建与解耦问题         |
| 结构型 | **如何组织类/对象结构** | 解决类与类之间的组合、接口适配、封装等   |
| 行为型 | **对象如何交互协作**   | 解决对象职责划分、交互流程、通信方式等问题 |


